#! /bin/env python3

import collections
import enum
import glob
import os
import shutil
import sys


class AmbergenMarkupTagDefinition:

    def __init__(self, export_mode='AUTO', begin=None, end=None,
                 is_region=False, is_exclusive=False, preserve=False,
                 html_mode='BOTH', html_tag=None, html_values={},
                 end_func=None):

        self.export_mode = export_mode

        self.begin = begin
        self.end = end

        # Create a new region for this tag.
        self.is_region = is_region

        # Only this tag's end sequence will be recognized.
        self.is_exclusive = is_exclusive

        # If this tag ends upon a newline.
        self.is_single_line = begin and not end

        # If all characters (namely whitespace) are preserved for this
        # tag.
        self.preserve = preserve

        self.html_mode = html_mode
        self.html_tag = html_tag
        self.html_values = html_values

        self.end_func = end_func

    def callEndFunc(self, generator):
        if self.end_func:
            self.end_func(generator)

    def shouldExport(self, inner=None):
        if self.export_mode == 'NEVER':
            return False
        elif self.export_mode == 'AUTO' and inner == "":
            return False

        return True

    def canPrune(self, inner=None):
        return (self.export_mode == 'AUTO' or self.export_mode == 'PRUNE') and inner == ""

    def export(self, inner=None, values=None, html_mode=None):
        if not self.shouldExport(inner):
            return ""

        values = values or self.html_values
        html_mode = html_mode or self.html_mode

        html = ""

        # Begin tag.
        if self.html_tag and html_mode in ['BOTH', 'BEGIN', 'SINGLE']:
            html += "<" + self.html_tag

            for name in sorted(values):
                if values[name] != None:
                    html += " " + name + "=\"" + values[name] + "\""

            html += "/>" if self.html_mode == 'SINGLE' else ">"

        # Inner.
        if inner:
            html += inner

        # End tag.
        if self.html_tag and html_mode in ['BOTH', 'END'] and self.html_mode != 'SINGLE':
            html += "</" + self.html_tag + ">"

        return html


class AmbergenMarkupRegion:

    def __init__(self, tag_name, definition, inner=""):
        self.tag_name = tag_name
        self.definition = definition

        self.inner = inner
        self.values = self.definition.html_values.copy()

        self.prune = False

    def __str__(self):
        s = {
            "tag_name": self.tag_name,
            "inner": self.inner,
            "values": self.values,
        }

        return str(s)

    def prependInner(self, text):
        self.inner = text + self.inner

    def appendInner(self, text):
        self.inner += text

    def hasInner(self):
        return self.inner != ""

    def shouldExport(self):
        return self.definition.shouldExport(self.inner)

    def canPrune(self, previous_region=None, next_region=None):
        return self.definition.canPrune(self.inner)

    def checkPrune(self, previous_region=None, next_region=None):
        if not self.canPrune():
            return

        if previous_region and previous_region.canPrune():
            if previous_region.definition.html_tag == self.definition.html_tag:
                if previous_region.definition.html_mode == 'BEGIN' and self.definition.html_mode == 'END':
                    self.prune = True
                    return

        if next_region and next_region.canPrune():
            if next_region.definition.html_tag == self.definition.html_tag:
                if self.definition.html_mode == 'BEGIN' and next_region.definition.html_mode == 'END':
                    self.prune = True

    def export(self):
        return self.definition.export(inner=self.inner, values=self.values)


class AmbergenMarkupGenerator:

    # ========================================
    #
    # Tag callback functions.

    def tagBlockEnd(generator):
        generator.appendRegion("paragraph_end", offset=1)
        generator.appendRegion("paragraph")

    def tagLinkUrlEnd(generator):
        url_region = generator.getRegion()
        link_region = generator.getRegion(["link", "embed_image", "embed_image_pixel", "embed_image_small"])

        if link_region.definition.html_tag == "img":
            link_region.values["src"] = url_region.inner
            link_region.values["alt"] = link_region.inner

            link_region.inner = ""
        else:
            link_region.values["href"] = url_region.inner

    # ========================================
    #
    # Tag definition table.

    TAG_DEFINITIONS = {
        "paragraph": AmbergenMarkupTagDefinition(
            export_mode='PRUNE',
            html_mode='BEGIN', html_tag="p",
        ),
        "paragraph_end": AmbergenMarkupTagDefinition(
            export_mode='PRUNE',
            html_mode='END', html_tag="p"
        ),
        "normal": AmbergenMarkupTagDefinition(),
        "heading": AmbergenMarkupTagDefinition(
            begin="#",
            is_region=True,
            html_tag="h2",
            end_func=tagBlockEnd
        ),
        "italic": AmbergenMarkupTagDefinition(
            begin="/", end="/",
            html_tag="em"
        ),
        "bold": AmbergenMarkupTagDefinition(
            begin="*", end="*",
            html_tag="strong"
        ),
        "underline": AmbergenMarkupTagDefinition(
            begin="_", end="_",
            html_tag="span", html_values={ "class": "underline" }
        ),
        "strikethrough": AmbergenMarkupTagDefinition(
            begin="~", end="~",
            html_tag="span", html_values={ "class": "strikethrough" }
        ),
        "code_block": AmbergenMarkupTagDefinition(
            begin="```", end="```",
            is_region=True, is_exclusive=True, preserve=True,
            html_tag="pre", html_values={ "class": "code-block" },
            end_func=tagBlockEnd
        ),
        "code_inline": AmbergenMarkupTagDefinition(
            begin="`", end="`",
            is_exclusive=True,
            html_tag="code", html_values={ "class": "code-inline" }
        ),
        "embed_image": AmbergenMarkupTagDefinition(
            export_mode='ALWAYS', begin="![", end="]",
            is_region=True,
            html_mode='SINGLE', html_tag="img", html_values={ "class": "embed" },
            end_func=tagBlockEnd
        ),
        "embed_image_small": AmbergenMarkupTagDefinition(
            export_mode='ALWAYS', begin="!small[", end="]",
            is_region=True,
            html_mode='SINGLE', html_tag="img", html_values={ "class": "embed-small" }
        ),
        "embed_image_pixel": AmbergenMarkupTagDefinition(
            export_mode='ALWAYS', begin="!pixel[", end="]",
            is_region=True,
            html_mode='SINGLE', html_tag="img", html_values={ "class": "embed image-pixel" },
            end_func=tagBlockEnd
        ),
        "link": AmbergenMarkupTagDefinition(
            begin="[", end="]",
            is_region=True,
            html_tag="a"
        ),
        "link_url": AmbergenMarkupTagDefinition(
            export_mode='NEVER', begin="(", end=")",
            is_region=True, is_exclusive=True,
            end_func=tagLinkUrlEnd
        ),
    }

    # ========================================
    #
    # Constructor.

    def __init__(self, source_path, only_metadata=False):
        self.source_path = source_path
        self.only_metadata = only_metadata

        self.metadata_length = 0
        self.metadata = {
            "title": "Title",
            "author": "Author",
            "date": "2000-01-01",
            "template": "article.html",
        }

        self.regions = []

        self.source = ""
        self.html = ""

        self.parse()

    # ========================================
    #
    # Preliminary metadata parsing.

    def parse(self):
        f = open(self.source_path, "r")
        self.source = f.read()
        f.close()

        self.parseMetadata()

        if not self.only_metadata:
            self.parseMarkup()
            self.export()

    def parseMetadata(self):
        SEPARATOR = "---"

        self.metadata_length = self.source.find(SEPARATOR)
        if self.metadata_length == -1:
            self.metadata_length = len(self.source)

        lines = self.source[:self.metadata_length].split("\n")
        for line in lines:
            line = line.strip().split(" ", 1)
            if len(line) < 2:
                continue

            self.metadata[line[0].strip()] = line[1].strip()

        self.metadata_length += len(SEPARATOR)

    # ========================================
    #
    # Region.

    def appendRegion(self, tag_name="normal", offset=0):
        index = max(len(self.regions) - offset, 0)

        # Remove empty regions.
        index_p = index - 1
        if index_p >= 0:
            region = self.regions[index_p]
            if region and not region.shouldExport():
                del self.regions[index_p]
                index = max(index - 1, 0)

        self.regions.insert(index, AmbergenMarkupRegion(tag_name, self.TAG_DEFINITIONS[tag_name]))

        return self.regions[index]

    def deleteRegion(self, region):
        del region

    def getRegion(self, tag_names=None, offset=0):
        if not tag_names:
            if len(self.regions) > 0:
                return self.regions[-(offset + 1)]
            else:
                return None

        for i in range(len(self.regions) - (offset + 1), 0, -1):
            region = self.regions[i]
            if region.tag_name in tag_names:
                return region

        return None

    def prependInner(self, html, region=None):
        region = region or self.regions[-1]
        region.prependInner(text)

    def appendInner(self, text, region=None):
        region = region or self.regions[-1]
        region.appendInner(text)

    # ========================================
    #
    # Tag.

    def beginTag(self, tag_name):
        self.active_tags[tag_name] = True

        tag = self.TAG_DEFINITIONS[tag_name]

        if tag.is_exclusive:
            self.exclusive_tag = tag_name

        if tag.is_region:
            self.appendRegion(tag_name)
        else:
            self.appendInner(tag.export(html_mode='BEGIN'))

    def endTag(self, tag_name):
        self.active_tags[tag_name] = False

        tag = self.TAG_DEFINITIONS[tag_name]

        tag.callEndFunc(self)

        if tag.is_exclusive:
            self.exclusive_tag = None

        if tag.is_region:
            self.appendRegion()
        else:
            self.appendInner(tag.export(html_mode='END'))

    # ========================================
    #
    # Main markup parsing.

    def nextCh(self, count=1):
        self.ci += count
        if self.ci >= len(self.source):
            return False

        self.ch = self.source[self.ci]
        return True

    def parseMarkup(self):
        self.active_tags = { x: False for x in self.TAG_DEFINITIONS }
        self.exclusive_tag = None

        self.escaped = False

        self.ci = self.metadata_length - 1
        self.ch = None

        self.empty_line_count = 0
        self.column = 0

        self.appendRegion("paragraph")

        while self.nextCh():
            latest_region = self.getRegion()

            if not latest_region.definition.preserve:
                # Escaping.
                if self.ch == "\\" and not self.escaped:
                    self.escaped = True
                    continue

                self.escaped = False

                # Newline/whitespace handling.
                if self.ch == "\n":
                    if self.empty_line_count == 0 and latest_region.hasInner():
                        self.appendInner(" ")
                    elif self.empty_line_count == 1:
                        self.appendRegion("paragraph_end")
                        self.appendRegion("paragraph")

                    self.empty_line_count += 1
                    self.column = 0

                    # Handle single-line tags.
                    for tag_name in self.TAG_DEFINITIONS:
                        if self.active_tags[tag_name] and self.TAG_DEFINITIONS[tag_name].is_single_line:
                            self.endTag(tag_name)

                    continue

                # Whitespace is ignored.
                if self.ch in " \t\r" and self.empty_line_count > 0:
                    column = 0
                    continue

                self.empty_line_count = 0
                self.column += 1

                if self.column == 1:
                    if self.source.startswith("---", self.ci):
                        self.nextCh(2)
                        self.appendInner("<hr>")
                        continue

            # Begin tags.
            tag_begin = None
            tag_begin_name = None
            for tag_name in self.TAG_DEFINITIONS:
                tag = self.TAG_DEFINITIONS[tag_name]
                if not self.active_tags[tag_name] and tag.begin and self.source.startswith(tag.begin, self.ci):
                    tag_begin = tag
                    tag_begin_name = tag_name
                    break

            if tag_begin and not self.exclusive_tag:
                self.nextCh(len(tag_begin.begin) - 1)
                self.beginTag(tag_begin_name)
                continue

            # End tags.
            tag_end = None
            tag_end_name = None
            for tag_name in self.TAG_DEFINITIONS:
                tag = self.TAG_DEFINITIONS[tag_name]
                if self.active_tags[tag_name] and tag.end and self.source.startswith(tag.end, self.ci):
                    tag_end = tag
                    tag_end_name = tag_name
                    break

            if tag_end and (not self.exclusive_tag or tag_end_name == self.exclusive_tag):
                self.nextCh(len(tag_end.end) - 1)
                self.endTag(tag_end_name)
                continue

            # Insert literal character.
            if self.ch == "<":
                self.appendInner("&lt")
            elif self.ch == ">":
                self.appendInner("&gt")
            else:
                self.appendInner(self.ch)

        self.appendRegion("paragraph_end")

    def export(self):
        # Prune empty tags.
        for i in range(len(self.regions)):
            region = self.regions[i]

            if not region.shouldExport():
                continue

            if i > 0: previous_region = self.regions[i - 1]
            else: previous_region = None

            if i < (len(self.regions) - 1): next_region = self.regions[i + 1]
            else: next_region = None

            region.checkPrune(previous_region, next_region)

        # Export regions.
        for region in self.regions:
            if not region.shouldExport():
                continue

            if region.prune:
                continue

            #print(region)

            self.html += region.export()


class Generator:

    def __init__(self, source_dir="", build_dir="public"):
        self.source_dir = os.path.abspath(source_dir)
        self.build_dir = os.path.abspath(build_dir)

        self.assets_dir = os.path.join(self.source_dir, "assets")
        self.content_dir = os.path.join(self.source_dir, "content")
        self.templates_dir = os.path.join(self.source_dir, "templates")

        print(f"Source dir: '{self.source_dir}'")
        print(f"Build dir: '{self.source_dir}'")

        self.templates = {}

    def getTemplate(self, path):
        t = self.templates.get(path)
        if not t:
            f = open(os.path.join(self.templates_dir, path), "r")
            t = f.read()
            f.close()

        return t

    def generateTemplatedHtml(self, source, body="", metadata={}):
        return source.format(
            title=metadata.get("title", "None"),
            author=metadata.get("author", "None"),
            date=metadata.get("date", "None"),
            body=body
        )

    def buildMarkupPage(self, markup, build_path):
        f = open(build_path, "w")
        f.write(self.generateTemplatedHtml(self.getTemplate(markup.metadata["template"]),
                                           body=markup.html, metadata=markup.metadata))
        f.close()

    def buildHtmlPage(self, source, build_path):
        f = open(build_path, "w")
        f.write(self.generateTemplatedHtml(source))
        f.close()

    def build(self):
        print("Building site...")

        shutil.copytree(self.assets_dir, os.path.join(self.build_dir, "assets"), dirs_exist_ok=True)

        # Enumerate .agm files in content/.
        source_paths = glob.glob(os.path.join(self.content_dir, "**"), recursive=True)

        for source_path in source_paths:
            if os.path.isdir(source_path):
                continue

            print(f"Building {source_path}...")

            build_path = source_path
            ext = os.path.splitext(source_path)[1]

            if ext == ".agm":
                build_path = build_path[len(self.content_dir) + 1:]
                build_path = os.path.join(self.build_dir, build_path)
                build_path = os.path.splitext(build_path)[0] + ".html"

                try: os.mkdir(os.path.dirname(build_path))
                except: pass

                markup = AmbergenMarkupGenerator(source_path)

                self.buildMarkupPage(markup, build_path)
            elif ext == ".html":
                f = open(source_path, "r")
                source = f.read()
                f.close()

                self.buildHtmlPage(source, build_path)


# ========================================
#
# Command-line utility usage.

if __name__ == "__main__":
    SOURCE_DIR = os.path.curdir
    BUILD_DIR = os.path.join(SOURCE_DIR, "public")

    SERVER_HOSTNAME = "0.0.0.0"
    SERVER_PORT = 8080

    # ========================================
    #
    # Helpers.

    def doMakeSourceDir(path):
        try:
            os.mkdir(os.path.join(SOURCE_DIR, path))
        except FileExistsError:
            pass

    def doMakeSourceFile(path, content=""):
        try:
            f = open(os.path.join(SOURCE_DIR, path), "x")
            f.write(content)
            f.close()
        except FileExistsError:
            pass

    # ========================================
    #
    # Commands.

    def commandBuild():
        ag = Generator(source_dir=SOURCE_DIR, build_dir=BUILD_DIR)
        ag.build()

    def commandInit():
        INITIAL_CSS = "\n".join([
            "",
            "body {",
            "  font-family: sans-serif;"
            "}",
            "",
        ])

        INITIAL_AGM_ARTICLE = "\n".join([
            "",
            "author Author",
            "template article.html",
            "---",
            "",
        ])

        INITIAL_HTML_INDEX = "\n".join([
            "",
            "<!DOCTYPE html>",
            "<html lang=\"en\">",
            "  <head>",
            "    <meta charset=\"utf-8\" />",
            "    <title>{title}</title>",
            "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
            "    <link rel=\"stylesheet\" href=\"/assets/style/main.css\" />",
            "  </head>",
            "  <body>",
            "    <p>Index</p>",
            "{listing_articles}",
            "  </body>",
            "</html>",
            "",
        ])

        INITIAL_HTML_404 = "\n".join([
            "",
            "<!DOCTYPE html>",
            "<html lang=\"en\">",
            "  <head>",
            "    <meta charset=\"utf-8\" />",
            "    <title>{title}</title>",
            "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
            "    <link rel=\"stylesheet\" href=\"/assets/style/main.css\" />",
            "  </head>",
            "  <body>",
            "    <div class=\"404-div\"><p class=\"404-text\">404 page not found</p></div>",
            "  </body>",
            "</html>",
            "",
        ])

        INITIAL_HTML_TEMPLATE = "\n".join([
            "",
            "<!DOCTYPE html>",
            "<html lang=\"en\">",
            "  <head>",
            "    <meta charset=\"utf-8\" />",
            "    <title>{title}</title>",
            "    <meta name=\"author\" content=\"{author}\" />",
            "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
            "    <link rel=\"stylesheet\" href=\"/assets/style/main.css\" />",
            "  </head>",
            "  <body>",
            "{body}",
            "  </body>",
            "</html>",
            "",
        ])

        doMakeSourceDir("assets")
        doMakeSourceDir("assets/images")
        doMakeSourceDir("assets/style")
        doMakeSourceFile("assets/style/main.css", INITIAL_CSS)
        doMakeSourceDir("content")
        doMakeSourceFile("content/index.html", INITIAL_HTML_INDEX)
        doMakeSourceFile("content/404.html", INITIAL_HTML_404)
        doMakeSourceDir("content/articles")
        doMakeSourceDir("content/about")
        doMakeSourceFile("content/about/index.agm", INITIAL_AGM_ARTICLE)
        doMakeSourceDir("templates")
        doMakeSourceFile("templates/article.html", INITIAL_HTML_TEMPLATE)

    def commandServe():
        from http.server import SimpleHTTPRequestHandler, HTTPServer

        class RequestHandler(SimpleHTTPRequestHandler):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, directory=BUILD_DIR, **kwargs)

        print(f"Starting server on {SERVER_HOSTNAME}:{SERVER_PORT}...")
        server = HTTPServer((SERVER_HOSTNAME, SERVER_PORT), RequestHandler)
        print("Server started, press Ctrl-C to stop")

        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass

        server.server_close()
        print("Server stopped")

    # ========================================
    #
    # Command determination.

    if len(sys.argv) > 1:
        COMMAND = sys.argv[1].lower().strip()
    else:
        COMMAND = "build"

    # Run command.
    if COMMAND == "build":
        commandBuild()
    elif COMMAND == "init":
        commandInit()
    elif COMMAND == "serve":
        commandBuild()
        commandServe()
    else:
        print(f"Unknown command '{COMMAND}'")
